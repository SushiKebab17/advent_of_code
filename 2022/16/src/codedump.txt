fn all_paths_pt1(
    complete_graph: &HashMap<Valve, ValveInfo>,
    (valve, dist): (&Valve, &u8),
    time: &mut u32,
    max: &mut u32,
    curr_release: &mut u32,
    visited: &mut HashSet<Valve>,
) {
    if *time + *dist as u32 > 30 {
        return;
    }
    *time += *dist as u32;
    *curr_release += (30 - *time) * complete_graph[valve].flow_rate;
    for adj_valveinfo in &complete_graph[valve].other_valves {
        let adj_valve = Valve((adj_valveinfo.0).0);
        if !visited.contains(&adj_valve) {
            visited.insert(adj_valve);
            all_paths_pt1(
                complete_graph,
                adj_valveinfo,
                time,
                max,
                curr_release,
                visited,
            );
            visited.remove(&adj_valve);
        }
    }
    *max = *max.max(curr_release);
    *curr_release -= (30 - *time) * complete_graph[valve].flow_rate;
    *time -= *dist as u32;
}

fn all_paths_me(
    complete_graph: &HashMap<Valve, ValveInfo>,
    (valve, dist): &(Valve, u8),
    me_time: &mut u32,
    elephant_time: &mut u32,
    max: &mut u32,
    curr_release: &mut u32,
    visited: &mut HashSet<Valve>,
    //
    me_curr_sol: &mut Vec<(Valve, u32)>,
    el_curr_sol: &mut Vec<(Valve, u32)>,
    space: String, //
) {
    if *me_time + *dist as u32 > 26 || *elephant_time + *dist as u32 > 26 {
        return;
    }

    *me_time += *dist as u32;
    *curr_release += (26 - *me_time) * complete_graph[valve].flow_rate;

    me_curr_sol.push((*valve, *me_time));
    // println!(
    //     "{}me, {}{}, {}, {}",
    //     space, valve.0[0], valve.0[1], dist, curr_release
    // );
    // if visited.len() == 7 {
    //     println!("{:?}", me_curr_sol);
    //     println!("{:?}", el_curr_sol);
    //     println!("{:?}", visited);
    //     std::io::stdin().read_line(&mut String::new()).unwrap();
    // }

    for adj_valveinfo in &complete_graph[valve].other_valves {
        let adj_valve = Valve((adj_valveinfo.0).0);
        // println!("{}{}{}", space, adj_valve.0[0], adj_valve.0[1]);
        // println!("{}{:?}", space, visited);
        if !visited.contains(&adj_valve) {
            let new = space.clone() + " ";
            let mut curr = adj_valveinfo;
            for valve in &complete_graph[&Valve(['A', 'A'])].other_valves {
                if valve.0 == adj_valve {
                    curr = valve;
                    break;
                }
            }
            visited.insert(adj_valve);
            all_paths_el(
                complete_graph,
                curr,
                me_time,
                elephant_time,
                max,
                curr_release,
                visited,
                me_curr_sol,
                el_curr_sol,
                new.clone(),
            );
            all_paths_me(
                complete_graph,
                adj_valveinfo,
                me_time,
                elephant_time,
                max,
                curr_release,
                visited,
                me_curr_sol,
                el_curr_sol,
                new.clone(),
            );
            visited.remove(&adj_valve);
        }
    }
    *max = *max.max(curr_release);
    *curr_release -= (26 - *me_time) * complete_graph[valve].flow_rate;
    *me_time -= *dist as u32;
    me_curr_sol.pop();
}

fn all_paths_el(
    complete_graph: &HashMap<Valve, ValveInfo>,
    (valve, dist): &(Valve, u8),
    me_time: &mut u32,
    elephant_time: &mut u32,
    max: &mut u32,
    curr_release: &mut u32,
    visited: &mut HashSet<Valve>,
    //
    me_curr_sol: &mut Vec<(Valve, u32)>,
    el_curr_sol: &mut Vec<(Valve, u32)>,
    space: String, //
) {
    if *me_time + *dist as u32 > 26 || *elephant_time + *dist as u32 > 26 {
        return;
    }
    *elephant_time += *dist as u32;
    *curr_release += (26 - *elephant_time) * complete_graph[valve].flow_rate;

    el_curr_sol.push((*valve, *elephant_time));
    // println!(
    //     "{}el, time:{}, {}{}, {}, {}",
    //     space, elephant_time, valve.0[0], valve.0[1], dist, curr_release
    // );
    // if visited.len() == 7 {
    //     println!("{:?}", me_curr_sol);
    //     println!("{:?}", el_curr_sol);
    //     println!("{:?}", visited);
    //     std::io::stdin().read_line(&mut String::new()).unwrap();
    // }

    for adj_valveinfo in &complete_graph[valve].other_valves {
        let adj_valve = Valve((adj_valveinfo.0).0);
        // println!("{}{}{}", space, adj_valve.0[0], adj_valve.0[1]);
        // println!("{}{:?}", space, visited);
        if !visited.contains(&adj_valve) {
            visited.insert(adj_valve.clone());
            let new = space.clone() + " ";
            all_paths_el(
                complete_graph,
                adj_valveinfo,
                me_time,
                elephant_time,
                max,
                curr_release,
                visited,
                me_curr_sol,
                el_curr_sol,
                new,
            );
            visited.remove(&adj_valve);
        }
    }
    *max = *max.max(curr_release);
    *curr_release -= (26 - *elephant_time) * complete_graph[valve].flow_rate;
    *elephant_time -= *dist as u32;
    el_curr_sol.pop();
}

all_paths_me(
    &complete_graph,
    (&Valve::new("AA"), &0),
    &mut me_time,
    &mut elephant_time,
    &mut max,
    &mut curr_release,
    &mut visited,
    //
    &mut me_curr_sol,
    &mut el_curr_sol,
    "".to_string(), //
);